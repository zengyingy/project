#ifndef NET_TIMERQUEUE_H
#define NET_TIMERQUEUE_H

#include <set>
#include <vector>
#include <queue>
#include <memory>

#include <boost/noncopyable.hpp>

#include "Mutex.h"
#include "Timestamp.h"
#include "Callbacks.h"
#include "Channel.h"

namespace net
{

	class EventLoop;
	class Timer;
	class TimerId;

	///
	/// A best efforts timer queue.
	/// No guarantee that the callback will be on time.
	///
	class TimerQueue : boost::noncopyable
	{
	public:

		TimerQueue(EventLoop* loop);
		~TimerQueue();

		///
		/// Schedules the callback to be run at given time,
		/// repeats if @c interval > 0.0.
		///
		/// Must be thread safe. Usually be called from other threads.
		// 一定是线程安全的，可以跨线程调用。通常情况下被其它线程调用。
		TimerId addTimer(const TimerCallback& cb,
			Timestamp when,
			double interval);

		void cancel(TimerId timerId);

	private:

		// FIXME: use unique_ptr<Timer> instead of raw pointers.
		// unique_ptr是C++ 11标准的一个独享所有权的智能指针
		// 无法得到指向同一对象的两个unique_ptr指针
		// 但可以进行移动构造与移动赋值操作，即所有权可以移动到另一个对象（而非拷贝构造）
		typedef std::pair<Timestamp, Timer*> Entry;
		//typedef std::set<Entry> TimerList;

		struct TimerCmp
		{
			bool operator()(Entry &a, Entry &b) const
			{
				return a.second->expiration() > b.second->expiration();
			}
		};

		typedef std::priority_queue<Entry,std::deque<Entry>,TimerCmp> TimerList;
		typedef std::pair<Timer*, int64_t> ActiveTimer;
		//typedef std::set<ActiveTimer> ActiveTimerSet;
		typedef std::priority_queue<ActiveTimer> ActiveTimerqueue;

		// 以下成员函数只可能在其所属的I/O线程中调用，因而不必加锁。
		// 服务器性能杀手之一是锁竞争，所以要尽可能少用锁
		void addTimerInLoop(Timer* timer);
		void cancelInLoop(TimerId timerId);
		// called when timerfd alarms
		void handleRead();
		// move out all expired timers
		// 返回超时的定时器列表
		std::vector<Entry> getExpired(Timestamp now);
		void reset(const std::vector<Entry>& expired, Timestamp now);

		bool insert(Timer* timer);

		EventLoop* loop_;		// 所属EventLoop
		const int timerfd_;
		Channel timerfdChannel_;
		// Timer list sorted by expiration
		TimerList timers_;	// timers_是按到期时间排序

							// for cancel()
							// timers_与activeTimers_保存的是相同的数据
							// timers_是按到期时间排序，activeTimers_是按对象地址排序
		//ActiveTimerSet activeTimers_;
		//ActiveTimerqueue activeTimers_;
		//ActiveTimerqueue cancelingTimers_;
		bool callingExpiredTimers_; /* atomic */
		//ActiveTimerSet cancelingTimers_;	// 保存的是被取消的定时器
	};

}
#endif  // NET_TIMERQUEUE_H
